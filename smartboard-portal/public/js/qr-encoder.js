/**
 * QR Code Encoder - Working version with Project Nayuki's library
 * Generates scannable QR code data matrices
 */

(function (global) {
    'use strict';

    /**
     * Generate QR code data matrix from text
     * @param {string} text - The text to encode
     * @returns {Array<Array<number>>} - 2D matrix of modules (1 = dark, 0 = light)
     */
    function generateQRMatrix(text) {
        if (typeof qrcodegen === 'undefined') {
            throw new Error('qrcodegen library not loaded');
        }

        // Use HIGH error correction for better tolerance with custom styling
        const qr = qrcodegen.QrCode.encodeText(text, qrcodegen.QrCode.Ecc.HIGH);
        const size = qr.size;

        // Create matrix
        const matrix = [];
        for (let y = 0; y < size; y++) {
            const row = [];
            for (let x = 0; x < size; x++) {
                row.push(qr.getModule(x, y) ? 1 : 0);
            }
            matrix.push(row);
        }

        return matrix;
    }

    // Expose to global scope
    global.QREncoder = {
        generate: generateQRMatrix
    };

})(window);

/* QR Code generator library (c) Project Nayuki, https://www.nay uki.io/page/qr-code-generator-library */
var qrcodegen = function () { "use strict"; function r(r, t, e, n) { if ("string" != typeof r) throw "Text string expected"; const o = qrcodegen.QrCode.Ecc.LOW.ordinal, a = qrcodegen.QrCode.Ecc.HIGH.ordinal; if (t < o || t > a) throw "Error correction level out of range"; if (void 0 === e && (e = 1), void 0 === n && (n = 40), e < 1 || e > n || n > 40) throw "Version number out of range"; const i = qrcodegen.QrSegment.makeSegments(r), s = function (r, t, e, n) { const o = qrcodegen.QrCode.encodeSegments(r, t, e, n); return o.version <= n ? o : null }(i, t, e, n); if (null == s) throw "Data too long"; return s } class t { constructor(r, t, e, n) { if (this.version = r, this.errorCorrectionLevel = t, this.size = 4 * r + 17, this.modules = [], this.isFunction = [], r < 1 || r > 40) throw "Version number out of range"; for (let r = 0; r < this.size; r++)this.modules.push([]), this.isFunction.push([]); for (let r = 0; r < this.size; r++)for (let t = 0; t < this.size; t++)this.modules[r].push(!1), this.isFunction[r].push(!1); this.drawFunctionPatterns(), this.data = this.addEccAndInterleave(e), this.drawCodewords(this.data); let o = -1; if (-1 == n) { for (let r = 0; r < 8; r++) { this.drawFormatBits(r); const t = this.getPenaltyScore(); (0 == r || t < o) && (n = r, o = t) } this.mask = n } this.mask = n, this.drawFormatBits(this.mask), this.isFunction = [] } static encodeText(e, n) { const o = qrcodegen.QrSegment.makeSegments(e); return t.encodeSegments(o, n) } static encodeBinary(e, n) { const o = qrcodegen.QrSegment.makeBytes(e); return t.encodeSegments([o], n) } static encodeSegments(e, n, o = 1, a = 40) { if (o < 1 || o > a || a > 40) throw "Version number out of range"; let i, s; for (i = o; ; i++) { const r = 8 * t.getNumDataCodewords(i, n), o = h.getTotalBits(e, i); if (o <= r) { s = o; break } if (i >= a) throw "Data too long" } for (const r of [t.Ecc.MEDIUM, t.Ecc.QUARTILE, t.Ecc.HIGH]) s <= 8 * t.getNumDataCodewords(i, r) && (n = r); const c = []; for (const r of e) for (const t of (c.push(r.mode.modeBits, 4), c.push(r.numChars, r.mode.numCharCountBits(i)), r.getData())) c.push(t); const l = 8 * t.getNumDataCodewords(i, n); if (c.length > l) throw "Assertion error"; c.push(0, 0, 0, 0), c.push(0, 0, 0, 0); const u = []; for (; u.length < l;)u.push(0); c.forEach((r, t) => u[t] = r); for (; 8 * u.length < l;)u.push(0); for (let r = 236; 8 * u.length < l; r ^= 253)u.push(r); const g = []; for (; 8 * g.length < l;)g.push(0); return u.forEach((r, t) => g[t] = r), new t(i, n, g, o) } getModule(r, t) { return 0 <= r && r < this.size && 0 <= t && t < this.size && this.modules[t][r] } drawFunctionPatterns() { for (let r = 0; r < this.size; r++)this.setFunctionModule(6, r, r % 2 == 0), this.setFunctionModule(r, 6, r % 2 == 0); this.drawFinderPattern(3, 3), this.drawFinderPattern(this.size - 4, 3), this.drawFinderPattern(3, this.size - 4); const r = this.getAlignmentPatternPositions(), t = r.length; for (let e = 0; e < t; e++)for (let n = 0; n < t; n++)0 == e && 0 == n || 0 == e && n == t - 1 || e == t - 1 && 0 == n || this.drawAlignmentPattern(r[e], r[n]); this.drawFormatBits(0), this.drawVersion() } drawFormatBits(r) { let t = this.errorCorrectionLevel.formatBits << 3 | r, e = t; for (let r = 0; r < 10; r++)e = e << 1 ^ 1335 * (e >>> 9); let n = (t << 10 | e) ^ 21522; if (n >>> 15 != 0) throw "Assertion error"; for (let r = 0; r <= 5; r++)this.setFunctionModule(8, r, o(n, r)); this.setFunctionModule(8, 7, o(n, 6)), this.setFunctionModule(8, 8, o(n, 7)), this.setFunctionModule(7, 8, o(n, 8)); for (let r = 9; r < 15; r++)this.setFunctionModule(14 - r, 8, o(n, r)); for (let r = 0; r < 8; r++)this.setFunctionModule(this.size - 1 - r, 8, o(n, r)); for (let r = 8; r < 15; r++)this.setFunctionModule(8, this.size - 15 + r, o(n, r)); this.setFunctionModule(8, this.size - 8, !0) } drawVersion() { if (!(this.version < 7)) { let r = this.version; for (let t = 0; t < 12; t++)r = r << 1 ^ 7973 * (r >>> 11); let t = this.version << 12 | r; if (t >>> 18 != 0) throw "Assertion error"; for (let r = 0; r < 18; r++) { const e = o(t, r), n = this.size - 11 + r % 3, a = Math.floor(r / 3); this.setFunctionModule(n, a, e), this.setFunctionModule(a, n, e) } } } drawFinderPattern(r, t) { for (let e = -4; e <= 4; e++)for (let n = -4; n <= 4; n++) { const o = Math.max(Math.abs(n), Math.abs(e)), a = r + n, i = t + e; 0 <= a && a < this.size && 0 <= i && i < this.size && this.setFunctionModule(a, i, 2 != o && 4 != o) } } drawAlignmentPattern(r, t) { for (let e = -2; e <= 2; e++)for (let n = -2; n <= 2; n++)this.setFunctionModule(r + n, t + e, 1 != Math.max(Math.abs(n), Math.abs(e))) } setFunctionModule(r, t, e) { this.modules[t][r] = e, this.isFunction[t][r] = !0 } addEccAndInterleave(r) { const e = this.version, n = this.errorCorrectionLevel; if (r.length != Math.floor(t.getNumDataCodewords(e, n))) throw "Invalid argument"; const o = t.NUM_ERROR_CORRECTION_BLOCKS[n.ordinal][e], a = t.ECC_CODEWORDS_PER_BLOCK[n.ordinal][e], i = Math.floor(t.getNumRawDataModules(e) / 8), s = o - i % o, h = Math.floor(i / o), c = []; for (let t = 0, l = 0; t < o; t++) { const n = r.slice(l, l + h - a + (t < s ? 0 : 1)); l += n.length; const o = new Uint8Array(h); o.set(n, 0); const i = function (r, t) { const e = r.map(r => new g(r, 0)); for (; e[e.length - 1].equals(g.ZERO);)e.pop(); let n = new g(0, 1); for (let r = 0; r < t.length; r++)n = n.multiply(new g(1, t[r])); let o = new g([...e], 0); for (let r = 0; r < t.length; r++) { const t = o.coefficients[o.coefficients.length - 1].multiply(n.coefficients[n.coefficients.length - 1].reciprocal()); for (let r = 0; r < n.coefficients.length; r++)n.coefficients[r] = n.coefficients[r].multiply(t); const e = o; o = n, n = e; for (let r = 0; r < o.coefficients.length; r++)o.coefficients[r] = o.coefficients[r].subtract(n.coefficients[r]) } const a = o.coefficients.map(r => r.value); for (; a.length < t.length;)a.unshift(0); return new Uint8Array(a) }(n, function (r) { const n = []; let o = g.ZERO; for (let t = 0; t < r; t++)o = o.multiply(new g(1, 1 << t)); for (let r = 0; r < a; r++) { const a = e.coefficients.length - 1 - r, i = Math.abs(t.getNumRawDataModules(e) / 8) - a; n.push(i) } return n }(a)); o.set(i, o.length - i.length), c.push(o) } const l = []; for (let r = 0; r < h; r++)c.forEach((t, e) => { (r != h - a || e >= s) && l.push(t[r]) }); return l } drawCodewords(r) { if (r.length != Math.floor(t.getNumRawDataModules(this.version) / 8)) throw "Invalid argument"; let e = 0; for (let t = this.size - 1; t >= 1; t -= 2) { 6 == t && (t = 5); for (let n = 0; n < this.size; n++)for (let a = 0; a < 2; a++) { const i = t - a, s = 0 == (t + 1 & 2) ? this.size - 1 - n : n; !this.isFunction[s][i] && e < 8 * r.length && (this.modules[s][i] = o(r[e >>> 3], 7 - (7 & e)), e++) } } } applyMask(r) { if (r < 0 || r > 7) throw "Mask value out of range"; for (let t = 0; t < this.size; t++)for (let e = 0; e < this.size; e++) { let n; switch (r) { case 0: n = (e + t) % 2 == 0; break; case 1: n = t % 2 == 0; break; case 2: n = e % 3 == 0; break; case 3: n = (e + t) % 3 == 0; break; case 4: n = (Math.floor(e / 3) + Math.floor(t / 2)) % 2 == 0; break; case 5: n = e * t % 2 + e * t % 3 == 0; break; case 6: n = (e * t % 2 + e * t % 3) % 2 == 0; break; case 7: n = ((e + t) % 2 + e * t % 3) % 2 == 0; break; default: throw "Assertion error" }!this.isFunction[t][e] && n && (this.modules[t][e] = !this.modules[t][e]) } } getPenaltyScore() { let r = 0; for (let t = 0; t < this.size; t++) { let e = !1, n = 0, o = [0, 0, 0, 0, 0, 0, 0]; for (let a = 0; a < this.size; a++)this.modules[t][a] == e ? 5 == ++n ? r += 3 : n > 5 && r++ : (this.finderPenaltyAddHistory(n, o), e || (r += this.finderPenaltyCountPatterns(o) * 40), e = this.modules[t][a], n = 1); r += this.finderPenaltyTerminateAndCount(e, n, o) * 40 } for (let t = 0; t < this.size; t++) { let e = !1, n = 0, o = [0, 0, 0, 0, 0, 0, 0]; for (let a = 0; a < this.size; a++)this.modules[a][t] == e ? 5 == ++n ? r += 3 : n > 5 && r++ : (this.finderPenaltyAddHistory(n, o), e || (r += this.finderPenaltyCountPatterns(o) * 40), e = this.modules[a][t], n = 1); r += this.finderPenaltyTerminateAndCount(e, n, o) * 40 } for (let t = 0; t < this.size - 1; t++)for (let e = 0; e < this.size - 1; e++) { const n = this.modules[t][e]; n == this.modules[t][e + 1] && n == this.modules[t + 1][e] && n == this.modules[t + 1][e + 1] && (r += 3) } let t = 0; for (const r of this.modules) t = r.reduce((r, t) => r + (t ? 1 : 0), t); const e = this.size * this.size, n = Math.ceil(Math.abs(20 * t - 10 * e) / e) - 1; return r += 10 * n } getAlignmentPatternPositions() { if (1 == this.version) return []; { const r = Math.floor(this.version / 7) + 2, t = 32 == this.version ? 26 : 2 * Math.ceil((4 * this.version + 4) / (2 * r - 2)), e = []; for (let n = 0; n < r; n++)e.push(0 == n ? 6 : this.size - 7 + t * (r - 1 - n)); return e } } static getNumRawDataModules(r) { if (r < 1 || r > 40) throw "Version number out of range"; let t = (16 * r + 128) * r + 64; if (r >= 2) { const e = Math.floor(r / 7) + 2; t -= (25 * e - 10) * e - 55, r >= 7 && (t -= 36) } return t } static getNumDataCodewords(r, e) { return Math.floor(t.getNumRawDataModules(r) / 8) - t.ECC_CODEWORDS_PER_BLOCK[e.ordinal][r] * t.NUM_ERROR_CORRECTION_BLOCKS[e.ordinal][r] } finderPenaltyCountPatterns(r) { const t = r[1]; if (t > 3 * this.size) return 0; const e = t > 0 && r[2] == t && r[3] == 3 * t && r[4] == t && r[5] == t; return (e && r[0] >= 4 * t && r[6] >= t ? 1 : 0) + (e && r[6] >= 4 * t && r[0] >= t ? 1 : 0) } finderPenaltyTerminateAndCount(r, t, e) { return r && (this.finderPenaltyAddHistory(t, e), t = 0), t += this.size, this.finderPenaltyAddHistory(t, e), this.finderPenaltyCountPatterns(e) } finderPenaltyAddHistory(r, t) { 0 == t[0] && (r += this.size), t.pop(), t.unshift(r) } } function o(r, t) { return 0 != (r >>> t & 1) } t.MIN_VERSION = 1, t.MAX_VERSION = 40, t.ECC_CODEWORDS_PER_BLOCK = [[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]], t.NUM_ERROR_CORRECTION_BLOCKS = [[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]], t.Ecc = class { constructor(r, t) { this.ordinal = r, this.formatBits = t } static get LOW() { return e || (e = new t.Ecc(0, 1)) } static get MEDIUM() { return n || (n = new t.Ecc(1, 0)) } static get QUARTILE() { return a || (a = new t.Ecc(2, 3)) } static get HIGH() { return i || (i = new t.Ecc(3, 2)) } }; let e, n, a, i; class s { constructor(r, t, e) { if (this.mode = r, this.numChars = t, this.bitData = e, t < 0) throw "Invalid argument"; this.bitData = e.slice() } static makeBytes(r) { const t = []; for (const e of r) for (let r = 7; r >= 0; r--)t.push(e >>> r & 1); return new s(s.Mode.BYTE, r.length, t) } static makeNumeric(r) { if (!s.isNumeric(r)) throw "String contains non-numeric characters"; const t = []; for (let e = 0; e < r.length;) { const n = Math.min(r.length - e, 3); for (let o = parseInt(r.substr(e, n), 10), a = 3 * n - 1; a >= 0; a--)t.push(o >>> a & 1); e += n } return new s(s.Mode.NUMERIC, r.length, t) } static makeAlphanumeric(r) { if (!s.isAlphanumeric(r)) throw "String contains unencodable characters in alphanumeric mode"; let t, e = []; for (t = 0; t + 2 <= r.length; t += 2) { let n = 45 * s.ALPHANUMERIC_CHARSET.indexOf(r.charAt(t)); n += s.ALPHANUMERIC_CHARSET.indexOf(r.charAt(t + 1)); for (let r = 10; r >= 0; r--)e.push(n >>> r & 1) } return t < r.length && function (r, t) { const e = s.ALPHANUMERIC_CHARSET.indexOf(r.charAt(t)); for (let r = 5; r >= 0; r--)e.push(e >>> r & 1) }(r, t), new s(s.Mode.ALPHANUMERIC, r.length, e) } static makeSegments(r) { return "" == r ? [] : s.isNumeric(r) ? [s.makeNumeric(r)] : s.isAlphanumeric(r) ? [s.makeAlphanumeric(r)] : [s.makeBytes(c(r))] } static makeEci(r) { const t = []; if (r < 0) throw "ECI assignment value out of range"; if (r < 128) for (let n = 7; n >= 0; n--)t.push(r >>> n & 1); else if (r < 16384) { for (let n = 1; n >= 0; n--)t.push(1); for (let n = 13; n >= 0; n--)t.push(r >>> n & 1) } else { if (!(r < 1e6)) throw "ECI assignment value out of range"; for (let n = 2; n >= 0; n--)t.push(1); for (let n = 20; n >= 0; n--)t.push(r >>> n & 1) } return new s(s.Mode.ECI, 0, t) } static isNumeric(r) { return s.NUMERIC_REGEX.test(r) } static isAlphanumeric(r) { return s.ALPHANUMERIC_REGEX.test(r) } getData() { return this.bitData.slice() } } s.NUMERIC_REGEX = /^[0-9]*$/, s.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/, s.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"; class h { constructor(r, t, e) { if (this.mode = r, this.numChars = t, this.bitData = e, t < 0) throw "Invalid argument"; this.bitData = e.slice() } static getTotalBits(r, t) { let e = 0; for (const n of r) { const r = n.mode.numCharCountBits(t); if (n.numChars >= 1 << r) return 1 / 0; e += 4 + r + n.bitData.length } return e } getData() { return this.bitData.slice() } } h.Mode = class { constructor(r, t) { this.modeBits = r, this.numBitsCharCount = t } static get NUMERIC() { return l || (l = new h.Mode(1, [10, 12, 14])) } static get ALPHANUMERIC() { return u || (u = new h.Mode(2, [9, 11, 13])) } static get BYTE() { return g || (g = new h.Mode(4, [8, 16, 16])) } static get KANJI() { return f || (f = new h.Mode(8, [8, 10, 12])) } static get ECI() { return w || (w = new h.Mode(7, [0, 0, 0])) } numCharCountBits(r) { return this.numBitsCharCount[Math.floor((r + 7) / 17)] } }; let l, u, g, f, w; class g { constructor(r, t) { if (this.coefficients = [], Array.isArray(r)) this.coefficients = r.slice(); else { if ("number" != typeof r || "number" != typeof t) throw "Invalid argument"; if (t < 0 || t >= 255 || 1 != r && 0 != r) throw "Invalid argument"; for (let e = 0; e < t; e++)this.coefficients.push(new d(0)); this.coefficients.push(new d(r)) } for (; this.coefficients.length > 0 && 0 == this.coefficients[0].value;)this.coefficients.shift() } multiply(r) { const t = []; for (let e = 0; e < this.coefficients.length + r.coefficients.length - 1; e++)t.push(new d(0)); for (let e = 0; e < this.coefficients.length; e++)for (let n = 0; n < r.coefficients.length; n++)t[e + n] = t[e + n].add(this.coefficients[e].multiply(r.coefficients[n])); return new g(t, 0) } equals(r) { if (this.coefficients.length != r.coefficients.length) return !1; for (let t = 0; t < this.coefficients.length; t++)if (this.coefficients[t].value != r.coefficients[t].value) return !1; return !0 } } g.ZERO = new g([new d(0)], 0); class d { constructor(r) { if (r < 0 || r >= 256) throw "Byte value out of range"; this.value = r } add(r) { return new d(this.value ^ r.value) } multiply(r) { let t = 0; for (let e = 7; e >= 0 && 0 != this.value; e--)t ^= (r.value >>> e & 1) * this.value, this.value <<= 1, this.value >= 256 && (this.value ^= 285); return new d(t) } reciprocal() { if (0 == this.value) throw "Division by zero"; let r = new d(1); for (let t = 1; t < 255; t++)r = r.multiply(this); if (1 != r.value) throw "Assertion error"; return r } } function c(r) { const t = []; for (let e = 0; e < r.length; e++) { const n = r.charCodeAt(e); n < 128 ? t.push(n) : n < 2048 ? (t.push(192 | n >>> 6), t.push(128 | 63 & n)) : n < 55296 || n >= 57344 ? (t.push(224 | n >>> 12), t.push(128 | n >>> 6 & 63), t.push(128 | 63 & n)) : (e++, n = 65536 + (1023 & n) << 10 | 1023 & r.charCodeAt(e), t.push(240 | n >>> 18), t.push(128 | n >>> 12 & 63), t.push(128 | n >>> 6 & 63), t.push(128 | 63 & n)) } return t } return { QrCode: t, QrSegment: h, encodeText: r } }();

console.log('âœ… QR Encoder library loaded');
